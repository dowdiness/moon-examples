# Building a Simple Regex Engine in MoonBit

**Generated by Claude 4**

A regular expression (regex) matches text according to pattern syntax. At its simplest, a regex of literal characters matches exactly that sequence in the input text. We will implement a function `regex_match(pattern, text)` that returns true if the entire text matches the given pattern. We build it incrementally in stages, using test-first development. For each new feature, we first write a test case, then extend the code to pass it. Each operator (., ?, *, ^, $) is added one at a time. In each step we rely on backtracking (recursive calls) to explore possibilities, similar to traditional regex engines. All code is in MoonBit, and comments explain the logic.

## 1. Literal Matching

First we handle the simplest case: exact literals. A pattern like "cat" should match only the string "cat" (every character must match in sequence). For example, "cat" should match "cat", but not "cart" or "ca". We write tests first, then code.

```moonbit
test {
  // Literal match: exact equality
  assert_eq!(regex_match1("hello", "hello"), true) // identical strings match
  assert_eq!(regex_match1("hello", "hell"), false) // text shorter than pattern fails
  assert_eq!(regex_match1("hello", "hello!"), false) // extra text fails
}
```

The implementation simply compares characters one by one (here we use recursion). If the pattern is empty, we succeed only if the text is also empty; otherwise we compare the first character and recurse on the remainders. This handles only literal characters (no special operators yet):

```moonbit
fn regex_match1(pattern : String, text : String) -> Bool {
  match (pattern.view(), text.view()) {
    // If pattern is empty, match only if text is also empty
    (p, t) if p.length() == 0 => t.length() == 0
    // If text is empty but pattern is not, fail
    (_, t) if t.length() == 0 => false
    // Compare first character: must be identical
    ([p0, ..], [t0, ..]) if p0 == t0 =>
      // Recurse on the rest of pattern and text
      regex_match1(pattern.substring(start=1), text.substring(start=1))
    (_, _) => false
  }
}
```

## 2. Wildcard .

Next we add the wildcard `.`, which matches any single character. For example, the pattern "h.llo" should match "hello" and "hallo", but not "hllo" (because the `.` must match one character). We write a test first:

```moonbit
test {
  // Wildcard . matches any single character
  assert_eq!(regex_match2("pal", "pal"), true)
  assert_eq!(regex_match2("h.llo", "hello"), true)
  assert_eq!(regex_match2("h.llo", "hallo"), true)
  assert_eq!(regex_match2("h.llo", "hllo"), false)
  assert_eq!(regex_match2(".", "A"), true) // single dot matches any one char
  assert_eq!(regex_match2(".", ""), false) // dot cannot match empty string
}
```

To implement `.` we adjust the character comparison: if the pattern's first character is '.' (dot character), it matches any (non-empty) character. Concretely, in the code above, we change the condition to check if `p0 == t0 || p0 == '.'` instead of just `p0 == t0`. So the code becomes:

```moonbit
fn regex_match2(pattern : String, text : String) -> Bool {
  match (pattern.view(), text.view()) {
    (p, t) if p.length() == 0 => t.length() == 0
    (_, t) if t.length() == 0 => false
    // Dot (.) matches any character
    ([p0, ..], [t0, ..]) if p0 == t0 || p0 == '.' =>
      regex_match2(pattern.substring(start=1), text.substring(start=1))
    (_, _) => false
  }
}
```

This handles `.` as a "match any char" wildcard. All other behavior remains the same.

## 3. Optional ?

Now we add the optional quantifier `?`, which means "zero or one of the preceding element". For example, `colou?r` matches both "color" and "colour". We write tests:

```moonbit
test {
  // ? means preceding char is optional (0 or 1 times)
  assert_eq!(regex_match3("colou?r", "color"), true)
  assert_eq!(regex_match3("colou?r", "colour"), true)
  assert_eq!(regex_match3("colou?r", "colouur"), false) // two 'u's fail
  assert_eq!(regex_match3("a?b", "b"), true)
  assert_eq!(regex_match3("a?b", "ab"), true)
  assert_eq!(regex_match3("a?b", "aab"), false)
}
```

To implement `?`, we check if the second character in the pattern is '?'. If so, the first element (at pattern[0]) is optional. We have two cases:
- Skip it entirely (zero occurrences): we remove both the character and `?` from the pattern, and try to match the rest of the pattern against the current text.
- Use it once (one occurrence): if the first character matches the text (using either equality or `.` wildcard), we remove both the character and `?` and consume one character of text, then recurse.

We insert this check at the top of the function before literal matching:

```moonbit
fn regex_match3(pattern : String, text : String) -> Bool {
  match (pattern.view(), text.view()) {
    (p, t) if p.length() == 0 => t.length() == 0
    // Handle ? quantifier: preceding char is optional
    ([p0, '?', ..], [t0, ..]) =>
      // Try skipping the char (0 occurrences)
      if regex_match3(pattern.substring(start=2), text) {
        true
      } else {
        // Try using it once
        match (text.length() > 0 && p0 == t0) || p0 == '.' {
          true =>
            regex_match3(pattern.substring(start=2), text.substring(start=1))
          false => false
        }
      }
    (_, t) if t.length() == 0 => false
    ([p0, ..], [t0, ..]) if p0 == t0 || p0 == '.' =>
      regex_match3(pattern.substring(start=1), text.substring(start=1))
    (_, _) => false
  }
}
```

Now the engine supports `?`. We tested `colou?r`, `a?b`, etc., and it works as expected.

## 4. Kleene Star *

Next is the Kleene star `*`, meaning "zero or more of the preceding element". For instance, `ab*c` matches "ac", "abc", "abbbc", and so on. Test cases:

```moonbit
test {
  // * means preceding char repeated 0 or more times
  assert_eq!(regex_match4("ab*c", "ac"), true)
  assert_eq!(regex_match4("ab*c", "abc"), true)
  assert_eq!(regex_match4("ab*c", "abbbbbc"), true)
  assert_eq!(regex_match4("ab*c", "abbxd"), false)
}
```

The logic is similar to `?` but in a loop/recursive way. When we see pattern[1] == '*', the character pattern[0] can match any number of times. We attempt:
- Zero occurrences: skip the char* entirely (pattern[2:] vs current text).
- One or more: if the first character matches, consume it from text and do not move past the `*` in the pattern (we keep pattern[0]* to allow more matches), then recurse.

Adding this into our function gives the full core engine with `.`, `?`, and `*`:

```moonbit
fn regex_match4(pattern : String, text : String) -> Bool {
  match (pattern.view(), text.view()) {
    (p, t) if p.length() == 0 => t.length() == 0
    // Handle ? quantifier: preceding char is optional
    ([p0, '?', ..], [t0, ..]) =>
      // Try skipping the char (0 occurrences)
      if regex_match4(pattern.substring(start=2), text) {
        true
      } else {
        // Try using it once
        match (text.length() > 0 && p0 == t0) || p0 == '.' {
          true =>
            regex_match4(pattern.substring(start=2), text.substring(start=1))
          false => false
        }
      }
    // Handle * quantifier
    ([p0, '*', ..], [t0, ..]) =>
      // Zero occurrences: if pattern is "a*bc", it becomes "bc" after skipping the first two characters
      if regex_match4(pattern.substring(start=2), text) {
        true
      } else {
        // One or more: check if we have at least one character that matches
        // For example: if pattern is "b*c" and text is "bbbc",
        // after one loop the text becomes "bbc" but the pattern stays the same
        match (text.length() > 0 && p0 == t0) || p0 == '.' {
          true => regex_match4(pattern, text.substring(start=1))
          false => false
        }
      }
    (_, t) if t.length() == 0 => false
    ([p0, ..], [t0, ..]) if p0 == t0 || p0 == '.' =>
      regex_match4(pattern.substring(start=1), text.substring(start=1))
    (_, _) => false
  }
}
```

This handles all core matching logic. With this engine, our earlier tests and the star tests all pass, as desired.

## 5. Anchors ^ and $

Finally, we add anchors. The caret `^` forces the match to start at the beginning of the text, and the dollar sign `$` forces the match to end at the end of the text. We write tests:

```moonbit
test {
  // ^ anchor: pattern must start at beginning
  assert_eq!(regex_match5("^hello", "hello"), true)
  assert_eq!(regex_match5("^hello", "ahello"), false)
  // $ anchor: pattern must end at end
  assert_eq!(regex_match5("lo$", "hello"), true)
  assert_eq!(regex_match5("lo$", "lo!"), false)
  // Both anchors: full-string match
  assert_eq!(regex_match5("^abc$", "abc"), true)
  assert_eq!(regex_match5("^abc$", "abca"), false)
}
```

To implement this, we strip the `^` and `$` from the pattern and set flags. Then:
- If `^` is present, we only try to match at the very start (no sliding).
- Otherwise, we try matching at each possible position in text (simulating the usual "search" semantics).
- In both cases, if `$` is present we require that the match consume the entire remainder of text.

Concretely, we wrap our regex_match logic in a loop (or one-shot) that respects anchors:

```moonbit
fn regex_match5(
  pattern : String,
  text : String,
  anchoredStart~ : Bool = false,
  anchoredEnd~ : Bool = false
) -> Bool {
  // Handle start (^) and end ($) anchors
  if pattern.length() > 0 && pattern.has_prefix("^") {
    regex_match5(
      // Skip the caret character (^) at the beginning
      pattern.substring(start=1),
      text,
      anchoredStart=true,
      anchoredEnd~,
    )
  } else if pattern.length() > 0 && pattern.has_suffix("$") {
    regex_match5(
      // Skip the last character ($)
      pattern.substring(start=0, end=pattern.length() - 1),
      text,
      anchoredStart~,
      anchoredEnd=true,
    )
  } else {
    // Define a helper that matches pattern at the beginning of 't',
    // requiring end of text if anchoredEnd
    fn inner_Match(p : String, t : String, end_anchor : Bool) -> Bool {
      match (p.view(), t.view()) {
        // If anchored end, text must be empty. Otherwise success.
        (p, t) if p.length() == 0 => not(end_anchor) || t.length() == 0
        // Handle ? quantifier: preceding char is optional (optional)
        ([p0, '?', ..], [t0, ..]) =>
          // Try skipping the char (0 occurrences)
          if inner_Match(p.substring(start=2), t, end_anchor) {
            true
          } else {
            // Try using it once
            match (t.length() > 0 && p0 == t0) || p0 == '.' {
              true =>
                inner_Match(
                  p.substring(start=2),
                  t.substring(start=1),
                  end_anchor,
                )
              false => false
            }
          }
        // Handle * quantifier (zero or more)
        ([p0, '*', ..], [t0, ..]) =>
          // Zero occurrences: if pattern is "a*bc", it becomes "bc" after skipping the first two characters
          if inner_Match(p.substring(start=2), t, end_anchor) {
            true
          } else {
            // One or more: check if we have at least one character that matches
            // For example: if pattern is "b*c" and text is "bbbc",
            // after one loop the text becomes "bbc" but the pattern stays the same
            match (t.length() > 0 && p0 == t0) || p0 == '.' {
              true => inner_Match(p, t.substring(start=1), end_anchor)
              false => false
            }
          }
        (_, t) if t.length() == 0 => false
        ([p0, ..], [t0, ..]) if p0 == t0 || p0 == '.' =>
          inner_Match(p.substring(start=1), t.substring(start=1), end_anchor)
        (_, _) => false
      }
    }
    // If anchored start, only try at position 0
    if anchoredStart {
      return inner_Match(pattern, text, anchoredEnd)
    }
    // Otherwise, try each starting position
    for i = 0; i <= text.length(); i = i + 1 {
      if inner_Match(pattern, text.substring(start=i), anchoredEnd) {
        return true
      }
    }
    return false
  }
}
```

With this final code, the anchors behave correctly. For example, `regex_match("^abc$", "abc")` succeeds, but `regex_match("^abc$", "xabcx")` fails.

All together, this MoonBit implementation – built step by step – provides a simple regex matcher supporting literals, `.`, `?`, `*`, and `^`/`$`. The code is cleanly structured, commented, and each feature was tested before implementation. Each new operator expands the matching logic in a controlled way, demonstrating the core backtracking approach used by many regex engines.

## Final Code (Combined)

Here's the complete implementation under 100 lines, including tests:

```moonbit
test {
  assert_eq!(regex_match("hello", "hello"), true)
  assert_eq!(regex_match("hello", "hell"), false)
  assert_eq!(regex_match("h.llo", "hello"), true)
  assert_eq!(regex_match("h.llo", "hllo"), false)
  assert_eq!(regex_match("colou?r", "color"), true)
  assert_eq!(regex_match("colou?r", "colouur"), false)
  assert_eq!(regex_match("ab*c", "abbbc"), true)
  assert_eq!(regex_match("lo$", "hello"), true)
  assert_eq!(regex_match("^hi", "ahihi"), false)
  assert_eq!(regex_match("ab*c", "abc"), true)
}

fn regex_match(
  pattern : String,
  text : String,
  anchoredStart~ : Bool = false,
  anchoredEnd~ : Bool = false
) -> Bool {
  // Handle start (^) and end ($) anchors
  if pattern.has_prefix("^") {
    regex_match(
      // Skip the caret character (^) at the beginning
      pattern.substring(start=1),
      text,
      anchoredStart=true,
      anchoredEnd~,
    )
  } else if pattern.length() > 0 && pattern.has_suffix("$") {
    regex_match(
      // Skip the last character ($)
      pattern.substring(start=0, end=pattern.length() - 1),
      text,
      anchoredStart~,
      anchoredEnd=true,
    )
  } else {
    // Define a helper that matches pattern at the beginning of 't',
    // requiring end of text if anchoredEnd
    fn inner_Match(p : String, t : String, end_anchor : Bool) -> Bool {
      match (p.view(), t.view()) {
        // If anchored end, text must be empty. Otherwise success.
        (p, t) if p.length() == 0 => not(end_anchor) || t.length() == 0
        // Handle ? quantifier: preceding char is optional (optional)
        ([p0, '?', ..], [t0, ..]) =>
          // Try skipping the char (0 occurrences)
          if inner_Match(p.substring(start=2), t, end_anchor) {
            true
          } else {
            // Try using it once
            match (t.length() > 0 && p0 == t0) || p0 == '.' {
              true =>
                inner_Match(
                  p.substring(start=2),
                  t.substring(start=1),
                  end_anchor,
                )
              false => false
            }
          }
        // Handle * quantifier (zero or more)
        ([p0, '*', ..], [t0, ..]) =>
          // Zero occurrences: if pattern is "a*bc", it becomes "bc" after skipping the first two characters
          if inner_Match(p.substring(start=2), t, end_anchor) {
            true
          } else {
            // One or more: check if we have at least one character that matches
            // For example: if pattern is "b*c" and text is "bbbc",
            // after one loop the text becomes "bbc" but the pattern stays the same
            match (t.length() > 0 && p0 == t0) || p0 == '.' {
              true => inner_Match(p, t.substring(start=1), end_anchor)
              false => false
            }
          }
        (_, t) if t.length() == 0 => false
        ([p0, ..], [t0, ..]) if p0 == t0 || p0 == '.' =>
          inner_Match(p.substring(start=1), t.substring(start=1), end_anchor)
        (_, _) => false
      }
    }
    // If anchored start, only try at position 0
    if anchoredStart {
      return inner_Match(pattern, text, anchoredEnd)
    }
    // Otherwise, try each starting position
    for i = 0; i <= text.length(); i = i + 1 {
      if inner_Match(pattern, text.substring(start=i), anchoredEnd) {
        return true
      }
    }
    return false
  }
}
```

This final code (with tests) implements the requested regex features step by step, as described above. The design is clear and commented, and each feature was verified by tests before adding it.
