# Building a Simple Regex Engine in MoonBit

**Generated by Claude 4**

A regular expression (regex) matches text according to pattern syntax. At its simplest, a regex of literal characters matches exactly that sequence in the input text. We will implement a function `regex_match(pattern, text)` that returns true if the entire text matches the given pattern. We build it incrementally in stages, using test-first development. For each new feature, we first write a test case, then extend the code to pass it. Each operator (., ?, *, ^, $) is added one at a time. In each step we rely on backtracking (recursive calls) to explore possibilities, similar to traditional regex engines. All code is in MoonBit, and comments explain the logic.

## 1. Literal Matching

First we handle the simplest case: exact literals. A pattern like "cat" should match only the string "cat" (every character must match in sequence). For example, "cat" should match "cat", but not "cart" or "ca". We write tests first, then code.

```moonbit
test "Literal match" {
  // Literal match: exact equality
  assert_eq(regex_match1("hello", "hello"), true) // identical strings match
  assert_eq(regex_match1("hello", "hell"), false) // text shorter than pattern fails
  assert_eq(regex_match1("hello", "hello!"), false) // extra text fails
}
```

The implementation simply compares characters one by one (here we use recursion). If the pattern is empty, we succeed only if the text is also empty; otherwise we compare the first character and recurse on the remainders. This handles only literal characters (no special operators yet):

```moonbit
fn safe_substring(s: String, start: Int) -> String {
  if start <= s.length() {
    try {
      s[start:].to_string()
    } catch {
      _ => ""
    }
  } else {
    ""
  }
}

fn regex_match1(pattern : String, text : String) -> Bool {
  match (pattern.get_char(0), text.get_char(0)) {
    // If pattern is empty, match only if text is also empty
    (None, None) => true
    // If text is empty but pattern is not, fail
    (Some(_), None) => false
    // If pattern is empty but text is not, fail
    (None, Some(_)) => false
    // Compare first character: must be identical
    (Some(p0), Some(t0)) if p0 == t0 =>
      // Recurse on the rest of pattern and text
      regex_match1(safe_substring(pattern, 1), safe_substring(text, 1))
    (_, _) => false
  }
}
```

## 2. Wildcard .

Next we add the wildcard `.`, which matches any single character. For example, the pattern "h.llo" should match "hello" and "hallo", but not "hllo" (because the `.` must match one character). We write a test first:

```moonbit
test "Wildcard" {
  // Wildcard . matches any single character
  assert_eq(regex_match2("pal", "pal"), true)
  assert_eq(regex_match2("h.llo", "hello"), true)
  assert_eq(regex_match2("h.llo", "hallo"), true)
  assert_eq(regex_match2("h.llo", "hllo"), false)
  assert_eq(regex_match2(".", "A"), true) // single dot matches any one char
  assert_eq(regex_match2(".", ""), false) // dot cannot match empty string
}
```

To implement `.` we adjust the character comparison: if the pattern's first character is '.' (dot character), it matches any (non-empty) character. Concretely, in the code above, we change the condition to check if `p0 == t0 || p0 == '.'` instead of just `p0 == t0`. So the code becomes:

```moonbit
fn regex_match2(pattern : String, text : String) -> Bool {
  match (pattern.get_char(0), text.get_char(0)) {
    (None, None) => true
    (Some(_), None) => false
    (None, Some(_)) => false
    // Dot (.) matches any character
    (Some(p0), Some(t0)) if p0 == t0 || p0 == '.' =>
      regex_match2(safe_substring(pattern, 1), safe_substring(text, 1))
    (_, _) => false
  }
}
```

This handles `.` as a "match any char" wildcard. All other behavior remains the same.

## 3. Optional ?

Now we add the optional quantifier `?`, which means "zero or one of the preceding element". For example, `colou?r` matches both "color" and "colour". We write tests:

```moonbit
test "Optional ?" {
  // ? means preceding char is optional (0 or 1 times)
  assert_eq(regex_match3("colou?r", "color"), true)
  assert_eq(regex_match3("colou?r", "colour"), true)
  assert_eq(regex_match3("colou?r", "colouur"), false) // two 'u's fail
  assert_eq(regex_match3("a?b", "b"), true)
  assert_eq(regex_match3("a?b", "ab"), true)
  assert_eq(regex_match3("a?b", "aab"), false)
}
```

To implement `?`, we check if the second character in the pattern is '?'. If so, the first element (at pattern[0]) is optional. We have two cases:
- Skip it entirely (zero occurrences): we remove both the character and `?` from the pattern, and try to match the rest of the pattern against the current text.
- Use it once (one occurrence): if the first character matches the text (using either equality or `.` wildcard), we remove both the character and `?` and consume one character of text, then recurse.

We insert this check at the top of the function before literal matching:

```moonbit
fn matchChar(pattern: Char, text: Char) -> Bool {
  match pattern {
    '.' => true
    _ if pattern == text => true
    _ => false
  }
}

fn regex_match3(pattern : String, text : String) -> Bool {
  match pattern.get_char(1) {
    // Handle ? quantifier: preceding char is optional
    Some('?') =>
      match (pattern.get_char(0), text.get_char(0)) {
        (Some(p0), Some(t0)) if matchChar(p0, t0) =>
          // Try using it once
          regex_match3(safe_substring(pattern, 2), safe_substring(text, 1)) ||
          // Try skipping the char (0 occurrences)
          regex_match3(safe_substring(pattern, 2), text)
        _ =>
          // Try skipping the char (0 occurrences)
          regex_match3(safe_substring(pattern, 2), text)
      }
    _ =>
      match (pattern.get_char(0), text.get_char(0)) {
        (None, None) => true
        (Some(_), None) => false
        (None, Some(_)) => false
        (Some(p0), Some(t0)) if p0 == t0 || p0 == '.' =>
          regex_match3(safe_substring(pattern, 1), safe_substring(text, 1))
        (_, _) => false
      }
  }
}
```

Now the engine supports `?`. We tested `colou?r`, `a?b`, etc., and it works as expected.

## 4. Kleene Star *

Next is the Kleene star `*`, meaning "zero or more of the preceding element". For instance, `ab*c` matches "ac", "abc", "abbbc", and so on. Test cases:

```moonbit
test "Kleene Star *" {
  // * means preceding char repeated 0 or more times
  assert_eq(regex_match4("ab*c", "ac"), true)
  assert_eq(regex_match4("ab*c", "abc"), true)
  assert_eq(regex_match4("ab*c", "abbbbbc"), true)
  assert_eq(regex_match4("ab*c", "abbxd"), false)
}
```

The logic is similar to `?` but in a loop/recursive way. When we see pattern[1] == '*', the character pattern[0] can match any number of times. We attempt:
- Zero occurrences: skip the char* entirely (pattern[2:] vs current text).
- One or more: if the first character matches, consume it from text and do not move past the `*` in the pattern (we keep pattern[0]* to allow more matches), then recurse.

Adding this into our function gives the full core engine with `.`, `?`, and `*`:

```moonbit
fn regex_match4(pattern : String, text : String) -> Bool {
  match pattern.get_char(1) {
    // Handle ? quantifier: preceding char is optional
    Some('?') =>
      match (pattern.get_char(0), text.get_char(0)) {
        (Some(p0), Some(t0)) if matchChar(p0, t0) =>
          regex_match4(safe_substring(pattern, 2), safe_substring(text, 1)) ||
          regex_match4(safe_substring(pattern, 2), text)
        _ => regex_match4(safe_substring(pattern, 2), text)
      }
    // Handle * quantifier
    Some('*') =>
      match (pattern.get_char(0), text.get_char(0)) {
        (Some(p0), Some(t0)) if matchChar(p0, t0) =>
          // Zero occurrences: skip the char* entirely
          regex_match4(safe_substring(pattern, 2), text) ||
          // One or more: consume one char but keep pattern
          regex_match4(pattern, safe_substring(text, 1))
        _ =>
          // Zero occurrences
          regex_match4(safe_substring(pattern, 2), text)
      }
    _ =>
      match (pattern.get_char(0), text.get_char(0)) {
        (None, None) => true
        (Some(_), None) => false
        (None, Some(_)) => false
        (Some(p0), Some(t0)) if p0 == t0 || p0 == '.' =>
          regex_match4(safe_substring(pattern, 1), safe_substring(text, 1))
        (_, _) => false
      }
  }
}
```

This handles all core matching logic. With this engine, our earlier tests and the star tests all pass, as desired.

## 5. Anchors ^ and $

Finally, we add anchors. The caret `^` forces the match to start at the beginning of the text, and the dollar sign `$` forces the match to end at the end of the text. We write tests:

```moonbit
test "Anchors ^ and $" {
  // ^ anchor: pattern must start at beginning
  assert_eq(regex_match5("^hello", "hello"), true)
  assert_eq(regex_match5("^hello", "ahello"), false)
  // $ anchor: pattern must end at end
  assert_eq(regex_match5("lo$", "hello"), true)
  assert_eq(regex_match5("lo$", "lo!"), false)
  // Both anchors: full-string match
  assert_eq(regex_match5("^abc$", "abc"), true)
  assert_eq(regex_match5("^abc$", "abca"), false)
}
```

To implement this, we strip the `^` and `$` from the pattern and set flags. Then:
- If `^` is present, we only try to match at the very start (no sliding).
- Otherwise, we try matching at each possible position in text (simulating the usual "search" semantics).
- In both cases, if `$` is present we require that the match consume the entire remainder of text.

Concretely, we wrap our regex_match logic in a loop (or one-shot) that respects anchors:

```moonbit
fn regex_match5(
  pattern : String,
  text : String,
  anchoredStart~ : Bool = false,
  anchoredEnd~ : Bool = false
) -> Bool {
  // Handle start (^) and end ($) anchors
  if pattern.length() > 0 && pattern.get_char(0) == Some('^') {
    regex_match5(
      // Skip the caret character (^) at the beginning
      safe_substring(pattern, 1),
      text,
      anchoredStart=true,
      anchoredEnd~,
    )
  } else if pattern.length() > 0 && pattern.get_char(pattern.length() - 1) == Some('$') {
    regex_match5(
      // Skip the last character ($)
      try {
        pattern[0:pattern.length() - 1].to_string()
      } catch {
        _ => ""
      },
      text,
      anchoredStart~,
      anchoredEnd=true,
    )
  } else {
    // Define a helper that matches pattern at the beginning of 't',
    // requiring end of text if anchoredEnd
    fn inner_Match(p : String, t : String, end_anchor : Bool) -> Bool {
      match p.get_char(1) {
        // Handle ? quantifier
        Some('?') =>
          match (p.get_char(0), t.get_char(0)) {
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 2), safe_substring(t, 1), end_anchor) ||
              inner_Match(safe_substring(p, 2), t, end_anchor)
            _ => inner_Match(safe_substring(p, 2), t, end_anchor)
          }
        // Handle * quantifier
        Some('*') =>
          match (p.get_char(0), t.get_char(0)) {
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 2), t, end_anchor) ||
              inner_Match(p, safe_substring(t, 1), end_anchor)
            _ => inner_Match(safe_substring(p, 2), t, end_anchor)
          }
        _ =>
          match (p.get_char(0), t.get_char(0)) {
            // If pattern is empty, check end anchor
            (None, None) => not(end_anchor) || true
            (None, Some(_)) => not(end_anchor)
            (Some(_), None) => false
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 1), safe_substring(t, 1), end_anchor)
            (_, _) => false
          }
      }
    }
    // If anchored start, only try at position 0
    if anchoredStart {
      return inner_Match(pattern, text, anchoredEnd)
    }
    // Otherwise, try each starting position
    for i = 0; i <= text.length(); i = i + 1 {
      if inner_Match(pattern, safe_substring(text, i), anchoredEnd) {
        return true
      }
    }
    return false
  }
}
```

With this final code, the anchors behave correctly. For example, `regex_match("^abc$", "abc")` succeeds, but `regex_match("^abc$", "xabcx")` fails.

All together, this MoonBit implementation – built step by step – provides a simple regex matcher supporting literals, `.`, `?`, `*`, and `^`/`$`. The code is cleanly structured, commented, and each feature was tested before implementation. Each new operator expands the matching logic in a controlled way, demonstrating the core backtracking approach used by many regex engines.

## Final Code (Combined)

Here's the complete implementation under 100 lines, including tests:

```moonbit
test "General test" {
  assert_eq(regex_match("hello", "hello"), true)
  assert_eq(regex_match("hello", "hell"), false)
  assert_eq(regex_match("h.llo", "hello"), true)
  assert_eq(regex_match("h.llo", "hllo"), false)
  assert_eq(regex_match("colou?r", "color"), true)
  assert_eq(regex_match("colou?r", "colouur"), false)
  assert_eq(regex_match("ab*c", "abbbc"), true)
  assert_eq(regex_match("lo$", "hello"), true)
  assert_eq(regex_match("^hi", "ahihi"), false)
  assert_eq(regex_match("ab*c", "abc"), true)
}

// Helper function is defined earlier in the document
// fn safe_substring(s: String, start: Int) -> String { ... }
// fn matchChar(pattern: Char, text: Char) -> Bool { ... }

fn regex_match(
  pattern : String,
  text : String,
  anchoredStart~ : Bool = false,
  anchoredEnd~ : Bool = false
) -> Bool {
  // Handle start (^) and end ($) anchors
  if pattern.length() > 0 && pattern.get_char(0) == Some('^') {
    regex_match(
      safe_substring(pattern, 1),
      text,
      anchoredStart=true,
      anchoredEnd~,
    )
  } else if pattern.length() > 0 && pattern.get_char(pattern.length() - 1) == Some('$') {
    regex_match(
      try {
        pattern[0:pattern.length() - 1].to_string()
      } catch {
        _ => ""
      },
      text,
      anchoredStart~,
      anchoredEnd=true,
    )
  } else {
    // Define a helper that matches pattern at the beginning of 't',
    // requiring end of text if anchoredEnd
    fn inner_Match(p : String, t : String, end_anchor : Bool) -> Bool {
      match p.get_char(1) {
        // Handle ? quantifier
        Some('?') =>
          match (p.get_char(0), t.get_char(0)) {
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 2), safe_substring(t, 1), end_anchor) ||
              inner_Match(safe_substring(p, 2), t, end_anchor)
            _ => inner_Match(safe_substring(p, 2), t, end_anchor)
          }
        // Handle * quantifier
        Some('*') =>
          match (p.get_char(0), t.get_char(0)) {
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 2), t, end_anchor) ||
              inner_Match(p, safe_substring(t, 1), end_anchor)
            _ => inner_Match(safe_substring(p, 2), t, end_anchor)
          }
        _ =>
          match (p.get_char(0), t.get_char(0)) {
            // If pattern is empty, check end anchor
            (None, None) => not(end_anchor) || true
            (None, Some(_)) => not(end_anchor)
            (Some(_), None) => false
            (Some(p0), Some(t0)) if matchChar(p0, t0) =>
              inner_Match(safe_substring(p, 1), safe_substring(t, 1), end_anchor)
            (_, _) => false
          }
      }
    }
    // If anchored start, only try at position 0
    if anchoredStart {
      return inner_Match(pattern, text, anchoredEnd)
    }
    // Otherwise, try each starting position
    for i = 0; i <= text.length(); i = i + 1 {
      if inner_Match(pattern, safe_substring(text, i), anchoredEnd) {
        return true
      }
    }
    return false
  }
}
```

This final code (with tests) implements the requested regex features step by step, as described above. The design is clear and commented, and each feature was verified by tests before adding it.
